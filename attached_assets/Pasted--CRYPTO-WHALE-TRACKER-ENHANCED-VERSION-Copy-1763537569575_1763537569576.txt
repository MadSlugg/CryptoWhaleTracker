// ============================================
// CRYPTO WHALE TRACKER - ENHANCED VERSION
// Copy this entire file into your Replit
// ============================================

// KNOWN EXCHANGE ADDRESSES DATABASE
// Updated regularly - add more as discovered
const EXCHANGE_ADDRESSES = {
  binance: [
    "bc1qm34lsc65zpw79lxes69zkqmk6ee3ewf0j77s3h",
    "34xp4vRoCGJym3xR7yCVPFHoCNxv4Twseo",
    "3LCGsSmfr24demGvriN4e3ft8wEcDuHFqh",
    "bc1qr4dl5wa7kl8yu792dceg9z5knl2gkn220lk7a9",
    "1NDyJtNTjmwk5xPNhjgAMu4HDHigtobu1s"
  ],
  coinbase: [
    "3D2oetdNuZUqQHPJmcMDDHYoqkyNVsFk9r",
    "3LYJfcfHPXYJreMsASk2jkn69LWEYKzexb",
    "36n452uGq1x4mK7bfyZR8wgE47AnBb2pzi",
    "3Cbq7aT1tY8kMxWLbitaG7yT6bPbKChq64"
  ],
  kraken: [
    "3FupZp77ySr7jwoLYEJ9mwzJpvoNBXmWi3",
    "35ULMyVnFoYaPaMxwHTRmaGdABpAThM4QR",
    "3ML7Drqxg8gmXS4Qnbh3f9kKmPU7GbNrDX"
  ],
  bitfinex: [
    "3D8ZWMjcUgG8KkNvmEVZV1FJCGxSjDRnLb",
    "1Kr6QSydW9bFQG1mXiPNNu6WpJGmUa9i1g"
  ],
  huobi: [
    "3JZq4atUahhuA9rLhXLMhhTo133J9rF97j",
    "38UmuUqPCrFmQo4khkomQwZ4VbY2nZMJ67"
  ],
  okex: [
    "1J1F3U7gHrCjsEsRimDJ3oYBiV24wA8FuV",
    "3MbYQMMmSkC3AgWkj9FMo5LsPTW1zBTwXL"
  ],
  bitstamp: [
    "3E8ociqZa9mZUSwGdSmAEMAoAxBK3FNDcd",
    "3BMEX8A3vX4E5gBxFVqC1phPJaXkTmKjmQ"
  ]
};

// Create reverse lookup map for O(1) searching
const addressToExchange = new Map();
Object.entries(EXCHANGE_ADDRESSES).forEach(([exchange, addresses]) => {
  addresses.forEach(addr => {
    addressToExchange.set(addr, exchange.toUpperCase());
  });
});

// ============================================
// HELPER FUNCTIONS
// ============================================

function checkExchangeAddress(address) {
  const exchange = addressToExchange.get(address);
  return {
    isExchange: !!exchange,
    exchange: exchange || null,
    label: exchange ? `${exchange} Wallet` : 'Unknown Wallet'
  };
}

function analyzeTransactionSignal(fromAddress, toAddress, amount) {
  const fromExchange = checkExchangeAddress(fromAddress);
  const toExchange = checkExchangeAddress(toAddress);
  
  let signal = {
    type: 'unknown',
    sentiment: 'neutral',
    icon: 'âšª',
    description: 'Wallet to wallet transfer'
  };
  
  if (toExchange.isExchange) {
    signal = {
      type: 'exchange_deposit',
      exchange: toExchange.exchange,
      sentiment: 'bearish',
      icon: 'ðŸ”´',
      description: `Sent to ${toExchange.exchange}`,
      analysis: 'Potential sell pressure - large deposit to exchange'
    };
  } else if (fromExchange.isExchange) {
    signal = {
      type: 'exchange_withdrawal',
      exchange: fromExchange.exchange,
      sentiment: 'bullish',
      icon: 'ðŸŸ¢',
      description: `Withdrawn from ${fromExchange.exchange}`,
      analysis: 'Likely moving to cold storage - bullish signal'
    };
  }
  
  // Add size-based severity
  if (amount > 1000) {
    signal.severity = 'critical';
    signal.sizeIcon = 'ðŸ‹ðŸ‹ðŸ‹';
  } else if (amount > 500) {
    signal.severity = 'high';
    signal.sizeIcon = 'ðŸ‹ðŸ‹';
  } else if (amount > 100) {
    signal.severity = 'medium';
    signal.sizeIcon = 'ðŸ‹';
  } else {
    signal.severity = 'low';
    signal.sizeIcon = 'ðŸŸ';
  }
  
  return {
    ...signal,
    fromExchange: fromExchange.isExchange,
    toExchange: toExchange.isExchange,
    fromLabel: fromExchange.label,
    toLabel: toExchange.label
  };
}

function formatBTC(amount) {
  return new Intl.NumberFormat('en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(amount);
}

function formatUSD(amount) {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(amount);
}

function getRelativeTime(timestamp) {
  const now = Date.now();
  const diff = now - timestamp;
  
  const seconds = Math.floor(diff / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  
  if (days > 0) return `${days}d ago`;
  if (hours > 0) return `${hours}h ago`;
  if (minutes > 0) return `${minutes}m ago`;
  return `${seconds}s ago`;
}

function shortenAddress(address, startChars = 6, endChars = 4) {
  if (!address || address.length <= startChars + endChars) return address;
  return `${address.slice(0, startChars)}...${address.slice(-endChars)}`;
}

// ============================================
// ADDRESS ACTIVITY LOOKUP
// ============================================

async function getAddressActivity(address) {
  try {
    const response = await fetch(
      `https://blockchain.info/rawaddr/${address}?limit=10`
    );
    const data = await response.json();
    
    return {
      address: data.address,
      balance: data.final_balance / 100000000,
      totalReceived: data.total_received / 100000000,
      totalSent: data.total_sent / 100000000,
      transactionCount: data.n_tx,
      transactions: data.txs.slice(0, 10),
      firstSeen: data.txs[data.txs.length - 1]?.time * 1000,
      lastSeen: data.txs[0]?.time * 1000
    };
  } catch (error) {
    console.error('Error fetching address activity:', error);
    return null;
  }
}

// ============================================
// CURRENT BTC PRICE (Binance API)
// ============================================

async function getCurrentBTCPrice() {
  try {
    const response = await fetch(
      'https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT'
    );
    const data = await response.json();
    return parseFloat(data.price);
  } catch (error) {
    console.error('Error fetching BTC price:', error);
    return 68000; // Fallback price
  }
}

// ============================================
// WHALE TRANSACTION FETCHING
// ============================================

async function fetchWhaleTransactions(minBTC = 100) {
  try {
    // Using Blockchain.com unconfirmed transactions
    const response = await fetch(
      'https://blockchain.info/unconfirmed-transactions?format=json'
    );
    const data = await response.json();
    
    const btcPrice = await getCurrentBTCPrice();
    const minSatoshis = minBTC * 100000000;
    
    const whaleTransactions = data.txs
      .filter(tx => {
        const totalOutput = tx.out.reduce((sum, output) => sum + output.value, 0);
        return totalOutput >= minSatoshis;
      })
      .map(tx => {
        const amountBTC = tx.out.reduce((sum, output) => sum + output.value, 0) / 100000000;
        const amountUSD = amountBTC * btcPrice;
        
        const fromAddress = tx.inputs[0]?.prev_out?.addr || 'Unknown';
        const toAddress = tx.out[0]?.addr || 'Unknown';
        
        const signal = analyzeTransactionSignal(fromAddress, toAddress, amountBTC);
        
        return {
          hash: tx.hash,
          timestamp: tx.time * 1000,
          amountBTC,
          amountUSD,
          fromAddress,
          toAddress,
          confirmations: 0,
          signal,
          size: tx.size,
          fee: tx.fee / 100000000
        };
      })
      .sort((a, b) => b.timestamp - a.timestamp);
    
    return whaleTransactions;
  } catch (error) {
    console.error('Error fetching whale transactions:', error);
    return [];
  }
}

// ============================================
// EXCHANGE FLOW STATISTICS
// ============================================

function calculateExchangeFlow(transactions) {
  const stats = {
    toExchanges: {},
    fromExchanges: {},
    totalIn: 0,
    totalOut: 0,
    netFlow: 0,
    sentiment: 'neutral'
  };
  
  transactions.forEach(tx => {
    if (tx.signal.toExchange) {
      const exchange = tx.signal.exchange;
      stats.toExchanges[exchange] = (stats.toExchanges[exchange] || 0) + tx.amountBTC;
      stats.totalIn += tx.amountBTC;
    }
    
    if (tx.signal.fromExchange) {
      const exchange = tx.signal.exchange;
      stats.fromExchanges[exchange] = (stats.fromExchanges[exchange] || 0) + tx.amountBTC;
      stats.totalOut += tx.amountBTC;
    }
  });
  
  stats.netFlow = stats.totalOut - stats.totalIn;
  
  if (stats.netFlow > 100) {
    stats.sentiment = 'bullish';
    stats.sentimentIcon = 'ðŸŸ¢';
    stats.sentimentText = 'Net Outflow (Bullish)';
  } else if (stats.netFlow < -100) {
    stats.sentiment = 'bearish';
    stats.sentimentIcon = 'ðŸ”´';
    stats.sentimentText = 'Net Inflow (Bearish)';
  } else {
    stats.sentiment = 'neutral';
    stats.sentimentIcon = 'âšª';
    stats.sentimentText = 'Balanced Flow';
  }
  
  return stats;
}

// ============================================
// HTML GENERATOR FUNCTIONS
// ============================================

function generateTransactionHTML(tx) {
  const sentimentClass = tx.signal.sentiment === 'bearish' ? 'bearish' : 
                        tx.signal.sentiment === 'bullish' ? 'bullish' : 'neutral';
  
  return `
    <div class="transaction-card ${sentimentClass}" data-hash="${tx.hash}">
      <div class="transaction-header">
        <div class="amount">
          ${tx.signal.sizeIcon} ${formatBTC(tx.amountBTC)} BTC
          <span class="usd-amount">(${formatUSD(tx.amountUSD)})</span>
        </div>
        <div class="time">${getRelativeTime(tx.timestamp)}</div>
      </div>
      
      <div class="transaction-details">
        <div class="address-row">
          <span class="label">From:</span>
          <span class="address" title="${tx.fromAddress}">
            ${tx.signal.fromLabel}
            <span class="address-short">${shortenAddress(tx.fromAddress)}</span>
          </span>
        </div>
        
        <div class="address-row">
          <span class="label">To:</span>
          <span class="address" title="${tx.toAddress}">
            ${tx.signal.toLabel}
            <span class="address-short">${shortenAddress(tx.toAddress)}</span>
          </span>
        </div>
      </div>
      
      ${tx.signal.type !== 'unknown' ? `
        <div class="signal-box ${sentimentClass}">
          <div class="signal-header">
            ${tx.signal.icon} ${tx.signal.sentiment.toUpperCase()} SIGNAL
          </div>
          <div class="signal-description">
            ${tx.signal.description}
          </div>
          <div class="signal-analysis">
            ${tx.signal.analysis}
          </div>
        </div>
      ` : ''}
      
      <div class="transaction-footer">
        <a href="https://blockchain.com/btc/tx/${tx.hash}" target="_blank" class="explorer-link">
          View on Explorer â†’
        </a>
        <button class="track-btn" onclick="trackAddress('${tx.fromAddress}')">
          Track Sender
        </button>
      </div>
    </div>
  `;
}

function generateStatsHTML(transactions, btcPrice) {
  const stats = calculateExchangeFlow(transactions);
  const totalValue = transactions.reduce((sum, tx) => sum + tx.amountUSD, 0);
  const largestTx = transactions.reduce((max, tx) => 
    tx.amountBTC > max.amountBTC ? tx : max, transactions[0]);
  
  return `
    <div class="stats-container">
      <div class="stat-card">
        <div class="stat-label">BTC Price</div>
        <div class="stat-value">${formatUSD(btcPrice)}</div>
      </div>
      
      <div class="stat-card">
        <div class="stat-label">Total Volume (24h)</div>
        <div class="stat-value">${formatBTC(stats.totalIn + stats.totalOut)} BTC</div>
        <div class="stat-sub">${formatUSD(totalValue)}</div>
      </div>
      
      <div class="stat-card">
        <div class="stat-label">Exchange Flow</div>
        <div class="stat-value ${stats.sentiment}">
          ${stats.sentimentIcon} ${formatBTC(Math.abs(stats.netFlow))} BTC
        </div>
        <div class="stat-sub">${stats.sentimentText}</div>
      </div>
      
      <div class="stat-card">
        <div class="stat-label">Largest Transaction</div>
        <div class="stat-value">${formatBTC(largestTx?.amountBTC || 0)} BTC</div>
        <div class="stat-sub">${formatUSD(largestTx?.amountUSD || 0)}</div>
      </div>
    </div>
    
    <div class="exchange-flow-details">
      <h3>Exchange Flow Breakdown</h3>
      <div class="flow-grid">
        <div class="flow-section">
          <h4>ðŸ”´ To Exchanges (Bearish)</h4>
          ${Object.entries(stats.t